<!DOCTYPE html>
<html lang="en">

<!-- Designed by Aryan Naraghi (aryan@cs) during September
     2011. Members of the Department of Computer Science & Engineering
     at the University of Washington may freely reuse the design of
     this website provided that credit to the original author is
     retained.
-->

<head>
  <meta charset="utf-8" />
  <meta name="author" content="Gaetano Borriello, Peter Ney, Sunjay Cauligi, Benjamin Du, Errol Limenta, and Whitney Schmidt" />
  <meta name="description" content="Course website for the Autumn 2013 offering of CSE 351 at the University of Washington. CSE 351 examines key computational abstraction levels below modern high-level languages; number representation, assembly language, introduction to C, memory management, the operating-system process model, high-level machine architecture including the memory hierarchy, and how high-level languages are implemented." />
  
  <title>CSE 351 Course Website - Autumn 2013</title>
  
  <link rel="stylesheet" href="include/style.css" type="text/css" media="all" />
  <link rel="stylesheet" href="include/print.css" type="text/css" media="print" />
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-25912195-1']);
    _gaq.push(['_trackPageview']);
    
    (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })();
  </script>
</head>

<body>
  <header>    
    <a href="index.html">
      <hgroup>
        <h1>CSE 351: The Hardware/Software Interface</h1>
        <h2>Autumn 2013 Course Website <span>Return home &raquo;</span></h2>
      </hgroup>
    </a>
  </header>
  
  <nav>
    <p><a href="index.html">Home</a></p>
    <ul>
      <li><span><a href="schedule.html">Schedule</a></span>
        <ul>
          <li><a href="goals-and-syllabus.html">Goals and Syllabus</a></li>
          <li><a href="policies.html">Course Policies</a></li>
          <li><a href="announcements.html">Announcements</a></li>
        </ul>
      </li>
      
      <li><span>Labs</span>
        <ul>
          <li><a href="lab-0.html">Lab 0</a></li>
          <li><a href="lab-1.html">Lab 1</a></li>
          <li><a href="lab-2.html">Lab 2</a></li>
          <li><a href="lab-3.html">Lab 3</a></li>
          <li><a href="lab-4.html">Lab 4</a></li>
          <li><a href="lab-5.html">Lab 5</a></li>
<!--
-->
        </ul>
      </li>

      <li><span>Homeworks</span>
        <ul>
          <li><a href="homework-1.html">Homework 1</a></li>
          <li><a href="homework-2.html">Homework 2</a></li>
          <li><a href="homework-3.html">Homework 3</a></li>
          <li><a href="homework-4.html">Homework 4</a></li>
<!--
-->
        </ul>
      </li>
      
	  <li><span>Catalyst Tools</span>
		<ul>
		  <li><a href="https://catalyst.uw.edu/gopost/board/gaetano/34380/">Discussion Board</a></li>
		  <li><a href="https://catalyst.uw.edu/collectit/dropbox/gaetano/28796">Assignment Drop Box</a></li>
		  <li><a href="https://catalyst.uw.edu/gradebook/gaetano/80221">Grade Book</a></li>
          <li><a href="https://catalyst.uw.edu/umail/form/gaetano/4003">Anonymous Feedback</a></li>
		</ul>
	  </li>
      
	  <li><span>Resources</span>
		<ul>
		  <li><a href="gdb.html">Using GDB to debug C</a></li>
		  <li><a href="videos.html">Videos from Coursera version of CSE351</a></li>
		  <li><a href="past-exams.html">Past Exams</a></li>
		  <li><a href="http://www.cs.washington.edu/lab/homeVMs/homeVMs.shtml">VM Information</a></li>
		  <li><a href="http://courses.cs.washington.edu/courses/cse390a/">CSE390A Web</a></li>
		  <li><a href="http://courses.cs.washington.edu/courses/cse351/10sp/docs/linux-instructions.html">Linux tips for CSE351</a></li>
		</ul>
	  </li>
      
    </ul>
  </nav>
  
  <div id="content">



<h1>Lab 5: Writing a Dynamic Storage Allocator</h1>

<table>
  <tr>
	<th>Assigned</th>
	<td>Monday, November 25, 2013</td>
  </tr>

  <tr>
	<th>Due Date</th>
    <!-- NOTE: update the dropbox due/close times when updating the due date. -->
	<td><em>Friday, December 6, 2013 at 5:00pm</em></td>
  </tr>

  <tr>
	<th>Files</th>
	<td><a href="labs/lab5/lab5.tar.gz">lab5.tar.gz</a></td>
  </tr>

  <tr>
    <th>Submissions</th>
    <!-- NOTE: this link is duplicated at the end of the file. -->
    <td>Submit your completed mm.c file <a href="https://catalyst.uw.edu/collectit/assignment/gaetano/28796/116479">here</a>.
  </tr>
</table>


<h2>Overview</h2>

<p>In this lab you will be writing a dynamic storage allocator for C
programs, i.e., your own version of the malloc and free routines.  It is quite involved.  <em>Start early!</em></p>

<h2>Optional Practice Problems</h2>
<p>We are providing some extra homework-style practice
problems for memory allocation in case you find them helpful in preparing for
lab 5.  They will not be graded (no credit), they are just good practice.
Read section 9.9 from the textbook for review.  (Note "word" means 4 bytes for these problems.)</p>
<ol>
	<li>Practice Problem 9.6</li>
    <li>Practice Problem 9.7</li>
    <li>Practice Problem 9.10</li>
	<li>Homework Problem 9.15</li>
	<li>Homework Problem 9.16</li>
</ol>



<h2>Instructions</h2>

<p>Start by
extracting <code>lab5.tar.gz</code> to a
directory where you plan to do your work:</p>

<pre><code>wget cs.washington.edu/education/courses/cse351/13au/labs/lab5/lab5.tar.gz
tar xzvf lab5.tar.gz</code></pre>

<p>This will cause a number of files to be unpacked in a directory
called lab5. The only file you will modify and turn in is <code>mm.c</code>.</p>

<p>(In the following instructions, we will assume that you are
executing programs in your local directory on <code>attu</code>. For
this lab, you can work anywhere there's a C compiler and <code>make</code>, but
make sure your allocator works on <code>attu</code>, where we'll be
testing it.)</p>

<p>Your dynamic storage allocator will consist of the following three
functions (and several helper functions), which are declared in <code>mm.h</code>
and defined in <code>mm.c</code>:</p>

<pre><code>int   mm_init(void);
void* mm_malloc(size_t size);
void  mm_free(void* ptr);</code></pre>

<p>The <code>mm.c</code> file we have given you partially implements
an allocator using an explicit free list. Your job is to complete this
implementation by filling out <code>mm_malloc()</code>
and <code>mm_free()</code>. The three main memory management functions
should work as follows:</p>

<ul>
  <li>
    <code>mm_init()</code> (provided): Before calling <code>mm_malloc()</code> or
    <code>mm_free()</code>, the application program (i.e., the
    trace-driven driver program that you will use to evaluate your
    implementation) calls mm_init to perform any necessary
    initializations, such as allocating the initial heap area. The
    return value is -1 if there was a problem in performing the
    initialization, 0 otherwise.</li>

  <li>
    <code>mm_malloc()</code>: The <code>mm_malloc()</code> routine
    returns a pointer to an allocated block payload of at least <code>size</code>
    bytes. (<code>size_t</code> is a type for describing sizes; it's an
    unsigned integer that can represent a size spanning all of memory, so
    on x86_64 it is a 64-bit integer.)  The entire allocated block should
    lie within the heap region and should not overlap with any other
    allocated block.
  </li>

  <li>
    <code>mm_free()</code>: The <code>mm_free()</code> routine frees
    the block pointed to by <code>ptr</code>. It returns nothing. This routine
    is only guaranteed to work when the passed pointer (<code>ptr</code>) was
    returned by an earlier call to <code>mm_malloc()</code> and has not yet been
    freed.  These semantics match the the semantics of the corresponding malloc
    and free routines in libc. Type <code>man malloc</code> in the shell for
    complete documentation.
  </li>

</ul>

<p>We will compare your implementation to the version of malloc
supplied in the standard C library (libc). Since the libc malloc
always returns payload pointers that are aligned to 8 bytes, your
malloc implementation should do likewise and always return 8-byte
aligned pointers.</p>


<h2>Provided Code</h2>

<p>We define a <code>BlockInfo</code> struct designed to be used as a
node in a doubly-linked explicit free list, and the following
functions for manipulating free lists:</p>

<ul>
  <li><code>BlockInfo* searchFreeList(int reqSize)</code>: returns a block
      of at least the requested size if one exists (and <code>NULL</code>
      otherwise).
  </li>

  <li><code>void insertFreeBlock(BlockInfo* blockInfo)</code>: inserts the
      given block in the free list in LIFO manner.
  </li>

  <li><code>void removeFreeBlock(BlockInfo* blockInfo)</code>: removes the
      given block from the free list.
  </li>
</ul>


<p>In addition, we implement <code>mm_init</code> and provide two helper
functions implementing important parts of the allocator:</p>

<ul>
  <li><code>void requestMoreSpace(int incr)</code>: enlarges the heap
       by <code>incr</code> bytes (if enough memory is available on
       the machine to do so).
  </li>

  <li><code>void coalesceFreeBlock(BlockInfo* oldBlock)</code>: coalesces any
      other free blocks adjacent in memory to <code>oldBlock</code> into a single
      new large block and updates the free list accordingly.
  </li>
</ul>

<p>Finally, we use a number of C Preprocessor macros to extract common
pieces of code (constants, annoying casts/pointer manipulation) that
might be prone to error. Each is documented in the code. You are
welcome to use macros as well, though the ones already included
in <code>mm.c</code> are the only ones we used in our sample solution,
so it's possible without more. For more info on macros, check
the <a href="http://gcc.gnu.org/onlinedocs/cpp/Macros.html">GCC
manual</a>.<p>
    <ul>
      <li><code>FREE_LIST_HEAD</code>: returns a pointer to
          the first block in the free list (the head of the free list).
      </li>
      <li><code>UNSCALED_POINTER_ADD</code> and <code>UNSCALED_POINTER_SUB</code>: useful
          for doing pointer arithmetic without worrying about the size
          of BlockInfo struct.
      </li>
      <li>Other short utilities for extracting the size field and
          determining block size.
      </li>
    </ul>

<p>Additionally, for debugging purposes, you may want to print the contents
of the heap. Here's code for a procedure to do so:</p>
<pre><code>
/* Print the heap by iterating through it as an implicit free list. */
static void examine_heap() {
  BlockInfo *block;

  /* print to stderr so output isn't buffered and not output if we crash */
  fprintf(stderr, "FREE_LIST_HEAD: %p\n", (void *)FREE_LIST_HEAD);

  for(block = (BlockInfo *)UNSCALED_POINTER_ADD(mem_heap_lo(), WORD_SIZE); /* first block on heap */
      SIZE(block->sizeAndTags) != 0 && block < mem_heap_hi();
      block = (BlockInfo *)UNSCALED_POINTER_ADD(block, SIZE(block->sizeAndTags))) {

    /* print out common block attributes */
    fprintf(stderr, "%p: %ld %ld %ld\t",
    (void *)block,
    SIZE(block->sizeAndTags),
    block->sizeAndTags & TAG_PRECEDING_USED,
    block->sizeAndTags & TAG_USED);

    /* and allocated/free specific data */
    if (block->sizeAndTags & TAG_USED) {
      fprintf(stderr, "ALLOCATED\n");
    } else {
      fprintf(stderr, "FREE\tnext: %p, prev: %p\n",
      (void *)block->next,
      (void *)block->prev);
    }
  }
  fprintf(stderr, "END OF HEAP\n\n");
}
</code></pre>

<h3>Memory System</h3>

<p>The <code>memlib.c</code> package simulates the memory system for your
dynamic memory allocator. In your allocator, you can call the
following functions (if you use the provided code for an explicit free
list, most uses of the memory system calls are already covered).</p>

<ul>
  <li>
    <code>void* mem_sbrk(int incr)</code>: Expands the heap
      by <code>incr</code> bytes, where <code>incr</code> is a
      positive non-zero integer and returns a pointer to the first
      byte of the newly allocated heap area. The semantics are
      identical to the Unix <code>sbrk</code> function, except
      that <code>mem_sbrk</code> accepts only a positive non-zero
      integer argument.  (Run <code>man sbrk</code> if you want to
      learn more about what this does in Unix.)
  </li>

  <li>
    <code>void* mem_heap_lo()</code>: Returns a pointer to the first
    byte in the heap
  </li>

  <li>
    <code>void* mem_heap_hi()</code>: Returns a pointer to the last
    byte in the heap.
  </li>

  <li>
    <code>size_t mem_heapsize()</code>: Returns the current size of
    the heap in bytes.
  </li>

  <li><code>size_t mem_pagesize()</code>: Returns the system's page
    size in bytes (4K on Linux systems).
  </li>
</ul>


<h2>The Trace-driven Driver Program</h2>

<p>The driver program <code>mdriver.c</code> in
the <code>lab5.tar.gz</code> distribution tests your <code>mm.c</code>
package for correctness, space utilization, and throughput.  Use the
command <code>make</code> to generate the driver code and run it with
the command <code>./mdriver&nbsp;-V</code> (the <code>-V</code> flag
displays helpful summary information as described below).</p>

<p>The driver program is controlled by a set of <em>trace files</em>
that are posted on <code>attu</code> (if you want to work on another
computer, you can copy these files and then update the TRACEDIR path
in <code>config.h</code>). Each trace file contains a sequence of
allocate and free directions that instruct the driver to call
your <code>mm_malloc</code> and <code> mm_free</code> routines in some
sequence. The driver and the trace files are the same ones we will use
when we grade your submitted <code>mm.c</code> file.</p>

<p>The <code>mdriver</code> executable accepts the following command
line arguments:</p>

<ul>
  <li>
    <code>-t &lt;tracedir&#62;</code>: Look for the default trace
    files in directory <code>tracedir</code> instead of the default
    directory defined in <code>config.h</code>.
  </li>

  <li>
    <code>-f &lt;tracefile&#62;</code>: Use one
    particular <code>tracefile</code> for testing instead of the
    default set of tracefiles.
  </li>

  <li>
    <code>-h</code>: Print a summary of the command line arguments.
  </li>

  <li>
    <code>-l</code>: Run and measure <code>libc</code> malloc in
    addition to the student's malloc package.
  </li>

  <li>
    <code>-v</code>: Verbose output. Print a performance breakdown for
    each tracefile in a compact table.
  </li>

  <li>
    <code>-V</code>: More verbose output. Prints additional diagnostic
    information as each trace file is processed.  Useful during
    debugging for determining which trace file is causing your malloc
    package to fail.
  </li>
</ul>


<h2>Programming Rules</h2>

<ul>
  <li>You should not change any of the interfaces in <code>mm.c</code>.</li>

  <li>
    You should not invoke any memory-management related library calls
      or system calls.  This excludes the use
      of <code>malloc</code>, <code>
      calloc</code>, <code>free</code>, <code>realloc</code>, <code>sbrk</code>, <code>brk</code>
      or any variants of these calls in your code.  (You may use all
      the functions in <code>memlib.c</code>, of course.)
  </li>

  <li>You are not allowed to define any global or <code>static</code>
    compound data structures such as arrays, structs, trees, or lists
    in your <code>mm.c</code> program.  You <em>are</em> allowed to
    declare global scalar variables such as integers, floats, and
    pointers in <code>mm.c</code>, but try to keep these to a minimum.
    (It is possible to complete the implementation of the explicit
    free list without adding any global variables.)
  </li>

  <li>
    For consistency with the <code>malloc</code> implementation
    in <code>libc</code>, which returns blocks aligned on 8-byte
    boundaries, your allocator must always return pointers that are
    aligned to 8-byte boundaries.  The driver will enforce this
    requirement for you.
  </li>
</ul>



<h2>Evaluation</h2>

<p>Your grade will be calculated (as a percentage) out of a total of
60 points as follows:</p>

<ul>
  <li><strong>Correctness (45 points).</strong> You will receive 5 points for
      each test performed by the driver program that your solution
      passes. (9 tests)

    </li>

  <li> <strong>Style (10 points).</strong>

    <ul>
      <li>Your code should use as few global variables as possible (ideally
        none!).

        </li>

      <li>
        Your code should be as clear and concise as possible.

        </li>

      <li>
        Since some of the unstructured pointer manipulation inherent to
        allocators can be confusing, short inline comments on steps of the
        allocation algorithms are also recommended.  (These will also help us
        give you partial credit if you have a partially working
        implementation.)

        </li>

      <li>
        Each function should have a header comment that describes
        what it does and how it does it.

        </li>
      </ul>
    </li>

  <li> <strong>Performance (5 points).</strong>  Performance represents a small
      portion of your grade.  We are most concerned about the correctness
      of your implementation.  For the most part a correct implementation
      will yield reasonable performance.  Two performance metrics will be
      used to evaluate your solution:


    <ul>
      <li> <i>Space utilization</i>: The peak ratio between the aggregate
        amount of memory used by the driver (i.e., allocated via
        <code>mm_malloc</code>  but not yet freed via
        <code>mm_free</code>) and the size of the heap used by your allocator. The
        optimal ratio is 1.  You should find good policies to minimize
        fragmentation in order to make this ratio as close as possible to the
        optimal.

        </li>

      <li>
        <i>Throughput</i>: The average number of operations completed per second.

        </li>
      </ul>

    The driver program summarizes the performance of your
    allocator by computing a <strong>performance index</strong>, P, which is a
    weighted sum of the space utilization and throughput:

<pre><code>P = 0.6U + 0.4 min (1, T/Tlibc)</code></pre>


    where U is your space utilization, T is your throughput, and
    T<sub>libc</sub> is the estimated throughput of <code>libc</code>
    malloc on your system on the default traces.  The performance
    index favors space utilization over throughput.  You will receive
    5(P+ 0.1) points, rounded <strong>up</strong> to the closest whole
    point.  For example, a solution with a performance index of 0.63
    or 63% will receive 4 performance points.  Our complete version of
    the explicit free list allocator has a performance index between
    0.7 and 0.8; it would receive 5 points.

    Observing that both memory and CPU cycles are expensive system
    resources, we adopt this formula to encourage balanced optimization of
    both memory utilization and throughput.  Ideally, the performance
    index will reach  P = 1 or  100% .  To receive a good
    performance score, you must achieve a balance between utilization and
    throughput.
    </li>
</ul>

<h2>Hints</h2>

<h3>Getting Started</h3>
<ul>
    <li>Read these instructions.</li>
    <li>Read over the provided code.</li>
    <li>Take notes while doing the above.</li>
    <li>Draw some diagrams of how the data structures should look before and after various operations.</li>
</ul>

<h3>Debugging</h3>
<ul>
  <li>Use the <code>mdriver</code> <code>-f</code> option. During initial
    development, using tiny trace files will simplify debugging and
    testing. We have included two such trace files (<code>short1-bal.rep</code>
    and <code>short2-bal.rep</code>) that you can use for initial debugging.
    </li>

  <li>Use the <code>mdriver</code> <code>-v</code> and <code>-V</code> options. The
    <code>-v</code> option will give you a detailed summary for each trace file.
    The <code>-V</code> will also indicate when each trace file is read, which
    will help you isolate errors.

    </li>

  <li>Compile with <code>gcc -g</code> and use <code>gdb</code>. The <code>-g</code>
    flag tells <code>gcc</code> to include debugging symbols, so <code>gdb</code> can
    follow the source code as it steps through the executable.  The
    <code>Makefile</code> should already be set up to do this.  A debugger will
    help you isolate and identify out of bounds memory references. You can specify
    any command line arguments for <code>mdriver</code> after the <code>run</code>
    command in <code>gdb</code> e.g. <code>run -f short1-bal.rep</code>.
  </li>

  <li>Understand every line of the malloc implementation in the
    textbook. The textbook has a detailed example of a simple
    allocator based on an implicit free list. Use this is a point of
    departure.  Don't start working on your allocator until you
    understand everything about the simple implicit list allocator.
  </li>

  <li>Write a function that treats the heap as an implicit list, and
   prints all header information from all the blocks in the heap. Using
   <code>fprintf</code> to print to <code>stderr</code> is helpful here
   because standard error is not buffered so you will get output from your
   print statements even if the next statement crashes your program.</li>

  <li>Encapsulate your pointer arithmetic in C preprocessor
    macros. Pointer arithmetic in memory managers is confusing and
    error-prone because of all the casting that is necessary. We have
    supplied maros that do this: see <code>UNSCALED_POINTER_ADD</code> and
    <code>UNSCALED_POINTER_SUB</code>.
  </li>

  <li>Use a profiler. You may find the <code>gprof</code> tool helpful
    for optimizing performance. (<code>man gprof</code> or searching online for
    <code>gprof</code> documentation will get you the basics.) If you
      use <code> gprof</code>, see the hint about debugging above for
      how to pass extra arguments to GCC in the <code>Makefile</code>.
  </li>

  <li>Start early! It is possible to write an efficient malloc package
  with a few pages of code. However, we can guarantee that it will be
  some of the most difficult and sophisticated code you have written
  so far in your career. So start early, and good luck!
  </li>
</ul>


<h2>Heap Consistency Checker</h2>

<p><em>This is an optional, but recommended, addition</em> that will help you
check to see if your allocator is doing what it should (or figure out what it's
doing wrong if not).  Dynamic memory allocators are notoriously tricky beasts to
program correctly and efficiently. They are difficult to program correctly
because they involve a lot of untyped pointer manipulation.  In addition to the
usual debugging techniques, you may find it helpful to write a heap checker that
scans the heap and checks it for consistency.</p>

<p>Some examples of what a heap checker might check are:</p>

<ul>
  <li>Is every block in the free list marked as free?</li>
  <li>Are there any contiguous free blocks that somehow escaped
    coalescing?</li>
  <li>Is every free block actually in the free list?</li>
  <li>Do the pointers in the free list point to valid free blocks?</li>
  <li>Do any allocated blocks overlap?</li>
  <li>Do the pointers in a heap block point to valid heap
    addresses?</li>
</ul>

<p>Your heap checker will consist of the function <code>int
  mm_check(void)</code> in <code>mm.c</code>.  Feel free to rename it, break it
into several functions, and call it wherever you want.  It should
check any invariants or consistency conditions you consider prudent.
It returns a nonzero value if and only if your heap is consistent.
This is not required, but may prove useful.  When you submit <code>
  mm.c</code>, make sure to remove any calls to <code>mm_check</code> as they will
slow down your throughput.</p>

<h2>Extra Credit</h2>

<p>As optional extra credit, implement a final memory allocation-related
function: <code>mm_realloc</code>. The signature for this function, which
you will find in your <code>mm.h</code> file, is:

<pre>
extern void* mm_realloc(void* ptr, size_t size);
</pre>

Similarly, you should find the following in your <code>mm.c</code> file:

<pre>
void* mm_realloc(void* ptr, size_t size) {
  // ... implementation here ...
}
</pre>

To receive credit, you should follow the contract of the C library's
<code>realloc</code> exactly (pretending that <code>malloc</code> and
<code>free</code> are <code>mm_malloc</code> and <code>mm_free</code>, etc.).
The man page entry for <code>realloc</code> says:

<pre>
       The realloc() function changes the size of the memory block pointed to by
       ptr to size bytes.  The contents will be unchanged in the range from the
       start of the region up to the minimum of the old and new sizes.  If the
       new size is larger than the old size, the added memory will not be
       initialized.  If ptr is NULL, then the call is equivalent to
       malloc(size), for all values of size; if size is equal to zero, and ptr
       is not NULL, then the call is equivalent to free(ptr).  Unless ptr is
       NULL, it must have been returned by an earlier call to malloc(), calloc()
       or realloc().  If the area pointed to was moved, a free(ptr) is done.
</pre>

A good test would be to compare the behavior of your <code>mm_realloc</code> to
that of <code>realloc</code>, checking each of the above cases.
Your implementation of <code>mm_realloc</code> should also be performant.
Avoid copying memory if possible, making use of nearby free blocks.
You should not use <code>memcpy</code> to copy memory; instead, copy
<code>WORD_SIZE</code> bytes at a time to the new destination while
iterating over the existing data.

<p>To run tracefiles that test <code>mm_realloc</code>, compile using
<code>make mdriver-realloc</code>. Then, run <code>mmdriver-realloc</code> 
with the <code>-f</code> flag to specify a tracefile, or first edit 
<code>config.h</code> to include additional realloc tracefiles in the 
default list.</p>

<h2>Submitting Your Work</h2>
  <!-- NOTE: this link is duplicated at the beginning of the file. -->
<p>Submit your <code>mm.c</code> file to
the <a href="https://catalyst.uw.edu/collectit/assignment/gaetano/28796/116479">Catalyst Drop Box for this assignment</a>.</p>

    </div>

  </body>
</html>


