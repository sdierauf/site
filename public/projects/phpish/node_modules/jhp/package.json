{
  "name": "jhp",
  "preferGlobal": "true",
  "description": "php-like syntax on top of nodejs (bring on the death threats!)",
  "version": "0.2.1",
  "homepage": "http://github.com/jaubourg/jhp",
  "repository": {
    "type": "git",
    "url": "git://github.com/jaubourg/jhp"
  },
  "author": {
    "name": "Julian Aubourg",
    "email": "j@ubourg.net",
    "url": "http://jaubourg.net/"
  },
  "bin": {
    "jhp": "bin/jhp"
  },
  "dependencies": {
    "commander": "0.6.x",
    "JQDeferred": "1.7.x",
    "mime": "1.2.x"
  },
  "engines": {
    "node": ">0.6"
  },
  "licenses": [
    {
      "type": "GPLv2",
      "url": "http://www.opensource.org/licenses/gpl-2.0.php"
    },
    {
      "type": "MIT",
      "url": "http://www.opensource.org/licenses/mit-license.php"
    }
  ],
  "readme": "JavaScript Hypertext Preprocessor\r\n=================================\r\n\r\nYou had nightmares about it, the frenchman did it!\r\n\r\n## WTF?\r\n\r\nJHP brings a PHP-like approach to Node.JS programming. To make it brief it's a *\"best of both worlds\"*, *\"worse of both worlds\"* kind of deal.\r\n\r\n## Install and run\r\n\r\n`npm install jhp -g`\r\n\r\nThen, use the command-line application `jhp`:\r\n\r\n```\r\n  Usage: jhp [options]\r\n\r\n  Options:\r\n\r\n    -h, --help           output usage information\r\n    -V, --version        output the version number\r\n    -d, --dir  [path]    Specify root directory (default './')\r\n    -p, --port [number]  Specify port number (default 80)\r\n```\r\n\r\n## Use\r\n\r\nIn the root directory, create `index.jhp`:\r\n\r\n```javascript\r\n<?\r\n\tresponse.setHeader( \"Content-Type\", \"text/plain\" );\r\n\tresponse.write( request.url );\r\n\tresponse.end();\r\n```\r\n\r\nSo, yes, it's pretty much the same as PHP:\r\n* files with the `.jhp` extension will be executed by the server,\r\n* while other files will be passed verbatim to the client (like a static file server would).\r\n\r\n`response` and `request` are the same objects you'd have in a `http.createServer` handler. Except that `request` has several new fields:\r\n* `body`, a promise that gets resolved with the request body (if and when the request has a body)\r\n\r\n  ```javascript\r\n\t<?\r\n\t\trequest.body.done(function( body ) {\r\n\t\t\tresponse.end( body );\r\n\t\t});\r\n  ```\r\n\r\n* `query`, a promise that gets resolved with the merge of both GET and POST parameters\r\n\r\n  ```javascript\r\n\t<?\r\n\t\tresponse.setHeader( \"Content-Type\", \"text/plain\" );\r\n\t\trequest.query.done(function( query ) {\r\n\t\t\tfor ( var key in query ) {\r\n\t?>\r\n\t<?= key ?>: <?= query[ key ] ?>\r\n\t<?\r\n\t\t\t}\r\n  \t\t\tresponse.end();\r\n\t\t});\r\n  ```\r\n\r\n* parsedURL, the request url as parsed by `require(\"url\").parse( url, true )`\r\n\r\n(promises provided by [JQDeferred](/jaubourg/jquery-deferred-for-node))\r\n\r\n**Remember**: this is still Node.JS we're talking about, so always call `reponse.end()` when you wanna flush the response!\r\n\r\n## What now?\r\n\r\nJHP is meant as a rapid prototyping and testing environment, nothing more, nothing less. It won't toast your bread.\r\n\r\nIt is licensed under both the GPLv2 and the MIT licenses.\r\n\r\nJHP is pretty fresh out of the oven, code is crude and features are sparse...\r\n\r\nSo it needs **you**:\r\n* what kind of pluggable architecture should it have?\r\n* what built-in features is it lacking?\r\n\r\nWhat we intend to work on right now is the static file serving part.\r\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/jaubourg/jhp/issues"
  },
  "_id": "jhp@0.2.1",
  "_shasum": "c35f91afa00c194479df6ccc47cddeb878af4be5",
  "_from": "jhp@",
  "_resolved": "https://registry.npmjs.org/jhp/-/jhp-0.2.1.tgz"
}
